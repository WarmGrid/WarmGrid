---
layout: post
title: 2017-12-07-区块链从入门到放弃
tags:
- Programming
status: publish
type: post
published: false

summary: '区块链从入门到放弃...'

---

# 区块链: 从入门到放弃...


[TOC]


本文是区块链相关技术的学习笔记, 从创建区块链的数字加密说起, 然后提到了几个经典的分布式共识算法, 最后是适用于大量节点的分布式共识. 本文不讨论区块链应用和前景, 虽然难免提上两句.



所谓区块链, 就是许多人一起使用的分布式记录系统, 每条记录占一个区块, 每个区块都指向它的上一个区块 (除起始区块外), 这样的一串区块就记录了全部历史信息.

区块链的系统没有固定中心, 这是与传统 "服务端-客户端" 结构的最大区别. 不依赖中心节点, 导致实现难度就高了许多, 设计区块链必须考虑以下问题:

1. 用户看到的整个历史记录必须是真实的, 用户能检验他手里的记录是否被篡改
2. 每条记录必须确实是由用户本人添加, 不能被冒名顶替
3. 整个系统对谁能新增区块要达成一致 (即使有网络延迟和恶意用户的干扰), 否则区块链就会分叉

以下逐个介绍区块链中所使用的技术



### 哈希函数和信息摘要

先讨论第一个要求, 用户下载区块链的全部历史之后, 得确信他看到的每条数据都是正确的. 这点由信息摘要算法来保证.

哈希函数 `y = hash(x)` 就是把任意长度数据 x 转换为定长数据 y 的函数, x 称为信息, y 称为信息的摘要. 哈希函数满足如下性质:

- 可以由 x 轻易算出 y
- 不能由 y 算出 x
- 即使知道 y, 也不可能轻易找到另一个 x2 使 `hash(x2) = y` (碰撞)
- x 的微小改动会导致 y 变成完全不一样的值

哈希函数有很多种, 比如最简单的逐个元素乘加 (`h = 31 * h + x[i]`, 对 x 中的每一位迭代计算, 取最后的值), 比如曾经广泛使用但不再安全的 MD5 等等, 比特币用的哈希函数是 SHA-256.

哈希函数要求正向算起来很容易, 但是逆推极其难. 另外, 因为 y 是定长的, 理论上必然存在多个 x 对应同一个 y 的情况, 但是在设计良好的哈希函数中, 很难人为构造出碰撞.

哈希函数要求 x 的微小改动会使 y 完全不同, 原因之一是防止通过距离推断 x 值, 通常一个 bit 的改变就足以让哈希值变得面目全非了, 例如:

    MD5("version1") = "966634ebf2fc135707d6753692bf4b1e"
    MD5("version2") = "2e0e95285f08a07dea17e7ee111b21c8"

在区块链中, 一般每个区块要记录两个摘要, 一个是本身区块存放数据的摘要, 一个是前一个区块的元数据的摘要, 用户拿到了数据后, 自己算一下摘要, 就知道数据是否改动过.

哈希函数还被用在很多地方:

- 在 key: value 结构中用来计算 key, 让 key 尽量平均分布
- 下载文件时检查数据的完整性
- 网站验证密码: 网站数据库一般不存用户的密码原文, 而是存密码的信息摘要 (减少被黑客攻击的损失, 黑客偷走哈希值没啥用), 用户下次登录时, 网站会拿用户的输入再次计算哈希值, 如果跟数据库里存的哈希值一样, 则可以认为用户输入了正确密码





### 非对称加密和数字签名

接下来要解决用户身份问题. 区块链需要在没有中心服务器存放帐号密码的前提下, 仍能够保证用户不被冒名顶替. 这里需要用到密码学的非对称加密, 它提供了一对技术, 正向使用就是加密信息, 反着用就是数字签名, 在区块链里我们更关心数字签名 (根据特定业务, 也会有侧重加密数据的区块链).

非对称加密要首先生成一对密钥 (公钥和私钥), 公钥可以随意发布到网上, 私钥需要自己保管好. 生成密钥非常轻松, 但拿到其中一个密钥很难推算出另一个. 比特币的客户端都提供生成账户的功能, 实质是创建了一对公钥私钥, 公钥就是账户名, 私钥可以理解为密码.

构造一对公钥私钥的算法是非对称加密的核心, 比如 RSA 加密, 它是利用大数因数分解的特征: 两个大质数很容易计算出乘积, 但是拿到乘积很难做因数分解 ([跨越千年的RSA算法](http://www.matrix67.com/blog/archives/5100)), 比特币用的是椭圆曲线加密.

算法不具体展开了. 总之最后我们创建了一对密钥, 公钥 `c` 和私钥 `d`, 对于任意信息 x, 在数学上都满足 `d(c(x)) = x` 和 `c(d(x)) = x`, 这时, 前者对应信息加密解密过程, 后者对应数字签名验证过程.

自己接收对方发来加密信息的场景: 把自己的公钥 `c` 发给对方, 对方把他的原始信息 `x` 以该公钥加密, 将 `c(x)` 发回, 之后自己使用私钥执行 `d(c(x))`, 就可以得到原文 `x` 了.

自己向对方发送签名的场景: 向对方发送信息 `x`, 公钥 `c`, 以及用私钥加密后的 `d(x)`, 对方收到这三者后, 计算 `c(d(x))`, 若结果跟 `x` 一致, 则可认为 `x` 确实是由掌握了私钥 `d` 的人发出的.

我们要求区块链的每条记录都经过数字签名, 就能保证信息确实是他本人发出的. 另一方面, 私钥泄露意味着攻击者可以用这个私钥签名任何信息, 在比特币里, 这时通常是把帐上的币都转走.

在实际操作中, 数字签名一般不签信息全文, 而是签全文的信息摘要. 发送加密信息也不是通篇都用非对称加密, 而是仅发送一个随机的对称加密密钥, 之后通信双方都使用这个临时生成的对称密钥来加密. 这是因为对称加密的计算量很小, 非对称加密的计算量很大.





### 分布式系统的共识问题

区块链接下来要面对的是, 这么多用户, 谁能合法的添加新的区块呢? 意见不一致时听谁的? 概括的说, 这是个在分布式系统中如何取得共识的问题. 考虑节点宕机, 网络延迟和恶意节点攻击, 设计分布式系统的最大难点就是在上述的不利条件下仍能达成共识.

- 有总共 2f+1 个节点的系统, 可以容忍最多出现 f 个故障节点
- 有总共 3f+1 个节点的系统, 可以容忍最多出现 f 个恶意节点

首先讨论不含恶意攻击的简单情况, 即在系统中只有故障节点, 但没有恶意节点时达成共识. 一般有 Paxos, Raft 及变种算法. 以下涉及算法细节的内容, 三言两语写不明白, 人家写的比我好 ([分布式共识 - VR, Raft 及 Paxos](http://blog.kongfy.com/2016/05/%e5%88%86%e5%b8%83%e5%bc%8f%e5%85%b1%e8%af%86consensus%ef%bc%9aviewstamped%e3%80%81raft%e5%8f%8apaxos/))



#### Paxos 算法

Paxos 算法命名来自希腊城邦 Paxos 中通过决议的流程, 相当复杂精巧.

Paxos 算法的各个节点要同时扮演三种角色:

- proposer: 提出提案, 等待大家批准
- acceptor: 表决提案, 回答同意或拒绝
- learner: 不参与投票, 收集大家的表决结果并结案

提案由提案编号和提案值组成, 每一个逻辑周期可以完成对一个提案的共识. 每周期分成 Prepare Accept 两阶段, 以及与这两阶段并行的达成共识的过程.

在 Prepare 阶段, 大家主要讨论提案编号. proposer 负责向 acceptor 提出编号为 n 的提案. acceptor 依据 n 和自己收到过的最大提案编号 m 决定自己的回复, 没有 m 则同意提案, n > m 则同意提案且告知 proposer 自己的 m 以及 m 值, n < m 则拒绝.

在 Accept 阶段, 大家讨论提案编号和提案值. proposer 收集上一阶段的回复, 如果发现大多数 acceptor 同意自己的提案, 则使用这些 acceptor 中最大的 m 做为提案, 没有 m 就用自己的提案. proposer 如果被大多数 acceptor 否决, 则准备下一轮提案. acceptor 当且仅当收到的 n 等于自己的 m 时同意提案, 并告知 learner 已同意提案.

与这两个阶段并行, learner 每时每刻统计 acceptor 同意过的提案, 如果 acceptor 连续发来多个提案, 只保留编号最大的. 超过半数 acceptor 同意的提案即为达成共识. ([PAXOS算法的理解](https://zhuanlan.zhihu.com/p/24788205))



#### Raft 算法

Raft 算法比 Paxos 容易理解和实现.

Raft 的节点分为 leader, candiate 和 follower. 在同一时刻, 只有不超过一个 leader 节点负责记录日志, 并定期给 follower 节点发送心跳消息, 表示自己还活着, 如果 follower 节点发现一段时间内收不到 leader 消息, 则把自己转换为 candiate, 等下一轮的 leader 选出来之后, 再进入正常的工作流程. ([Raft 选主的在线演示](https://raft.github.io/) [Raft 动画介绍](http://thesecretlivesofdata.com/raft/))

Raft 的各节点并不对等, 它需要 leader 节点, 应答客户端的负载都集中在这个 leader 上, 吞吐量受这个节点的限制, 同时它操作日志时依赖严格的顺序记录, 性能并不是很好.



##### 拜占庭容错算法

到目前为止已经够乱了, 但是之前讨论只针对系统节点发生延迟宕机的情况, 现在我们再给系统里加些恶意节点...

恶意节点就是不遵守规则, 可以发送任意消息的节点, 恶意节点当然也可以不回复, 假装自己宕机. 但恶意节点不能监听两个正常节点间的通信, 也不能获知它没有通信过的正常节点的决策.

恶意节点对应着拜占庭将军的比喻: 拜占庭的许多支军队必须在分开包围的状态下同时攻击敌人, 将军们依靠通信兵互相协商进攻意向和进攻时间, 而叛徒将军可以擅自变更进攻意向或进攻时间. 怎么才能找到一种分布式协议来协商从而让将军一致的行动呢? 拜占庭将军问题的实质, 是指在系统没有中心, 只依靠节点两两通信的情况下, 怎么保证系统能协商一致, 并抵御恶意节点干扰.

恶意节点目标是破坏系统一致性, 想象 `f+1` 个正常节点主张进攻,  `f` 个正常节点主张撤退, `f` 个恶意节点故意选了撤退的场景, 如果经过沟通后, 大家都正确传达了各自的意图, 并且都明白应该选择撤退, 那么我们认为恶意节点并没有达到目的. 只有当恶意节点骗过正常节点, 使主张进攻和主张撤退的节点都以为自己是大多数, 那这是成功的作恶.

能解决拜占庭将军问题的算法, 统称为拜占庭容错算法 (Byzantine Fault Tolerance), 其中的代表有 PBFT 等等.

Practical Byzantine Fault Tolerance 有
无签名和签名适用于同步系统

当节点发现leader作恶时，通过算法选举其他的replica为leader。
2、leader通过pre-prepare 消息把它选择的 value广播给其他replica节点，其他的replica节点如果接受则发送 prepare，如果失败则不发送。
3、一旦2f个节点接受prepare消息，则节点发送commit消息。
4、当2f+1个节点接受commit消息后，代表该value值被确定
如下图表示了4个节点，0为leader，同时节点3为fault节点，该节点不响应和发出任何消息。最终节点状态达到commited时，表示该轮共识成功达成。





**没有搞清楚的问题**

存在 `f` 个恶意节点时, 为什么系统至少要 `3f+1` 个节点才能保证运转?

解释一: 考虑最坏的情况, 系统总共 `N` 个节点, 其中 `f` 个忠诚节点宕机了, 剩下 `N-f` 个存活节点中, `f` 个恶意节点率先返回了假消息, 那么为让系统能正常运行, 我们得至少再等到另外的节点返回了真消息才能胜过 `f` 个假消息, 所以 `N-f-f > f`, 得到 `N > 3f`

解释二: 多数派需要达到 `2f+1`, 任意两个多数派之间至少有 `f+1` 个公共成员，而恶意进程最多 `f` 个










### 比特币共识算法 - 工作量证明

到目前为止, 针对系统中有故障节点的局面, 我们有 Paxos 和 Raft 算法, 对系统中同时有故障节点和恶意节点的局面, 我们有了 BFT 系列算法. 这样可以搭建比特币之类的应用了么? 还是不行. 因为这些算法都太慢了, 它们都是针对小型系统一两百个节点设计的, 没法用在互联网的海量用户中.

直到比特币的出现解决了这个问题, 比特币的共识算法叫做 POW 工作量证明, 核心在于遵守共识的比特币用户是有奖励的, 恶意节点由于只付出代价而收不到奖励, 变相受到了惩罚

之后基于奖励币的思路, 人们又发展出了一堆共识模型, 通称比特币共识

- POW (Proof of Work, 工作量证明) 例如比特币, 下大力气挖矿的人最有可能得到一个满足规则的随机数, 于是有权记账
- POS (Proof of Stake, 股权证明) 例如以太坊, 根据节点所占代币的比例和时间等比例降低挖矿难度, 从而加快找随机数的速度
- DPOS (Delegated Proof of Stake, 委任股权证明) 例如比特股, 类似董事会投票, 持币者投出一定数量的节点代理他们进行验证和记账

上述比特币共识算法, 都脱离不了币的奖励机制, 系统安全是由持币者维护保证的. 但是, 当区块链运用到商业应用时, 其承载的资产价值可能远远超出发行的币的价值, 这时由持币者保证系统安全稳定是不可靠的. POW和POS都是一种随机选择下一个区块上传者的方式

于是区块链的共识算法分成了两大类,

- 公有链: 对应比特币共识, 最多可以抵抗 49% 的恶意节点, 需要依靠币的价值体系, 不能运用在链上承载的价值超过币值的场合
- 私有链, 联盟链: 对应 BFT 共识, 最多可以抵抗 33% 的恶意节点, 不能用在规模巨大的网络


由于私有链是封闭生态的存储系统，因此采用Paxos类系统可以达到最优的性能；联盟链有半公开半开放特性，因此拜占庭容错是适合选择之一，例如IBM超级账本项目；对于公有链来说，这种共识算法的要求已经超出了普通分布式系统构建的范畴，再加上交易的特性，因此需要引入更多的安全考虑。

分布式系统不一定是完全去中心的, 如果它有个中心, 中心很容易成为最脆弱的地方



### 智能合约
