---
layout: post
title: 2017-12-07-区块链从入门到放弃
tags:
- Programming
status: publish
type: post
published: true

summary: '区块链从入门到放弃...'

---


[TOC]


本文是学习区块链相关技术的学习笔记, 不讨论区块链应用和前景.

区块链就是许多人一起使用的分布式记录, 一条记录占一个区块, 除起始区块外, 每个新区块都要指向它的上一个区块, 这样, 连在一起的区块就依次记录了全部历史信息.

区块链是给许多人一起用的, 且没有固定的中心节点, 所以设计时要考虑节点欺骗和数据一致的问题. 区块链必须具有以下功能:

1. 要保证一条记录确实是由本人添加的, 不能有人冒名顶替
2. 要保证历史记录不能被篡改
3. 要在网络延迟和恶意节点干扰的情况下, 对新增数据达成共识, 否则区块链就会分叉

区块链中使用了许多技术来实现这些功能, 主要包括数字签名, 信息摘要和共识算法.



### 哈希函数和信息摘要

先从最简单的开始, 用户得确信他看到的历史区块都是正确的区块, 这是由哈希函数算出数据的信息摘要来保证的.

哈希函数 `y = hash(x)` 就是把任意长度数据 x 转换为定长数据 y 的函数, 生成的 y 称为信息 x 的摘要. 哈希函数需要满足如下性质:

- 可以由 x 轻易的算出 y
- 不能从 y 逆向算出 x
- 即使知道 y, 也不可能轻易找到另一个 x2 使 `hash(x2) = y`
- x 的微小改动会导致 y 变成完全不一样的值

显然因为 y 是定长的, 理论上必然有很多个 x 对应同一个 y, 但是在设计良好的哈希函数中, 很难人为的构造出碰撞.

x 的微小改动会导致 y 变成完全不同的例子:

    MD5("version1") = "966634ebf2fc135707d6753692bf4b1e"
    MD5("version2") = "2e0e95285f08a07dea17e7ee111b21c8"

哈希函数有很多种实现, 最简单的逐个元素乘加 (`h = 31 * h + x[i]`, 对 x 中的每一位迭代计算, 取最后的值), 曾经广泛使用但不再安全的 MD5, 比特币使用的 SHA-256 等.

哈希函数用在很多地方, 在程序的字典数据结构中用来计算 key, 在下载文件时可以检查数据的完整性. 在网站数据库中, 为了防止黑客攻击一般不存用户的明文密码, 而是存密码的信息摘要, 用户下次登录时, 网站会拿用户新输入的密码再次计算哈希值, 如果跟数据库里存的哈希值一样, 则认为用户输入了正确密码.

在区块链中, 每个区块都要写入前一个区块里所有数据的信息摘要, 有了这个信息摘要就可以验算之前区块, 以及更早先区块的信息是否正确.



### 非对称加密和数字签名

有了信息摘要, 可以保证区块历史记录的每个字都不会被篡改, 某个区块里面写了 "甲给了乙 100 块钱", 改成 101 块就会导致信息摘要变得完全不同. 但是仍然需要解决用户身份的问题, 即发出信息的用户真的是本人吗? 这时就遇到数字签名的问题.

数字签名是对非对称加密的一种应用. 非对称加密 (公开密钥加密) 基于单向函数原理, 即正向操作非常简单, 逆向操作非常困难的函数, 例如, 两个大质数相乘很容易计算, 但是在以相乘结果做因数分解非常困难. RSA 加密就是利用大整数因数分解 ([跨越千年的RSA算法](http://www.matrix67.com/blog/archives/5100)), 此外还有比特币使用的椭圆曲线加密等等.

非对称加密首先要生成一对密钥, 公钥 `c` 和私钥 `d`, 公钥可以随意发布到网上, 私钥需要自己保管好. 生成密钥是非常轻松的正向操作, 但拿到其中一个密钥很难逆向算出另一个.

同时, 这一对密钥满足 `d(c(x)) = x` 和 `c(d(x)) = x`, 前者对应信息加密 / 解密的过程, 后者对应信息数字签名的签名 / 验证过程.

对方给自己发送加密信息的场景:

把自己的公钥 `c` 发给对方, 对方把他的原始信息 `x` 以该公钥加密, 将 `c(x)` 发回, 之后自己使用私钥执行 `d(c(x))`, 就可以得到原文 `x` 了.

自己向对方发送签名的场景:

向对方发送信息 `x`, 公钥 `c`, 以及用私钥加密后的 `d(x)`, 对方收到这三者后, 计算 `c(d(x))`, 若结果跟 `x` 一致, 则可认为 `x` 确实是由掌握了私钥 `d` 的人发出的.

当然在实际操作中, 对称加密的计算量很小, 非对称加密的计算量很大. 所以发送加密信息也不是通篇都用非对称加密, 而是仅发送一个随机的对称加密密钥, 之后通信双方都使用这个临时生成的对称密钥来加密. 数字签名一般也不签信息全文, 而是签全文的信息摘要.

在区块链中的每条记录都是要经过用户签名的, 这就保证了每条记录都由本人发出.



### 分布式系统的共识问题

区块链接下来要面对的是, 这么多用户, 谁能合法的添加新的区块呢? 意见不一致时听谁的? 概括的说, 这是个在分布式系统中如何取得共识的问题. 考虑节点宕机, 网络延迟和恶意节点攻击, 设计分布式系统的最大难点就是在上述的不利条件下仍能达成共识.

- 有总共 2f+1 个节点的系统, 可以容忍最多出现 f 个故障节点
- 有总共 3f+1 个节点的系统, 可以容忍最多出现 f 个恶意节点

首先讨论不含恶意攻击的简单情况, 即在系统中只有故障节点, 但没有恶意节点时达成共识. 一般有 Paxos, Raft 及变种算法. 以下涉及算法细节的内容, 三言两语写不明白, 人家写的比我好 ([分布式共识 - VR, Raft 及 Paxos](http://blog.kongfy.com/2016/05/%e5%88%86%e5%b8%83%e5%bc%8f%e5%85%b1%e8%af%86consensus%ef%bc%9aviewstamped%e3%80%81raft%e5%8f%8apaxos/))



#### Paxos 算法

Paxos 算法命名来自希腊城邦 Paxos 中通过决议的流程, 相当复杂精巧.

Paxos 算法的各个节点要同时扮演三种角色:

- proposer: 提出提案, 等待大家批准
- acceptor: 表决提案, 回答同意或拒绝
- learner: 不参与投票, 收集大家的表决结果并结案

提案由提案编号和提案值组成, 每一个逻辑周期可以完成对一个提案的共识. 每周期分成 Prepare Accept 两阶段, 以及与这两阶段并行的达成共识的过程.

在 Prepare 阶段, 大家主要讨论提案编号. proposer 负责向 acceptor 提出编号为 n 的提案. acceptor 依据 n 和自己收到过的最大提案编号 m 决定自己的回复, 没有 m 则同意提案, n > m 则同意提案且告知 proposer 自己的 m 以及 m 值, n < m 则拒绝.

在 Accept 阶段, 大家讨论提案编号和提案值. proposer 收集上一阶段的回复, 如果发现大多数 acceptor 同意自己的提案, 则使用这些 acceptor 中最大的 m 做为提案, 没有 m 就用自己的提案. proposer 如果被大多数 acceptor 否决, 则准备下一轮提案. acceptor 当且仅当收到的 n 等于自己的 m 时同意提案, 并告知 learner 已同意提案.

与这两个阶段并行, learner 每时每刻统计 acceptor 同意过的提案, 如果 acceptor 连续发来多个提案, 只保留编号最大的. 超过半数 acceptor 同意的提案即为达成共识. ([PAXOS算法的理解](https://zhuanlan.zhihu.com/p/24788205))



#### Raft 算法

Raft 算法比 Paxos 容易理解和实现.

Raft 的节点分为 leader, candiate 和 follower. 在同一时刻, 只有不超过一个 leader 节点负责记录日志, 并定期给 follower 节点发送心跳消息, 表示自己还活着, 如果 follower 节点发现一段时间内收不到 leader 消息, 则把自己转换为 candiate, 等下一轮的 leader 选出来之后, 再进入正常的工作流程. ([Raft 选主的在线演示](https://raft.github.io/) [Raft 动画介绍](http://thesecretlivesofdata.com/raft/))

Raft 的各节点并不对等, 它需要 leader 节点, 应答客户端的负载都集中在这个 leader 上, 吞吐量受这个节点的限制, 同时它操作日志时依赖严格的顺序记录, 性能并不是很好.



##### 拜占庭容错算法

到目前为止已经够乱了, 但是之前讨论只针对系统节点发生延迟宕机的情况, 现在我们再给系统里加些恶意节点...

恶意节点就是不遵守规则, 可以发送任意消息的节点, 恶意节点当然也可以不回复, 假装自己宕机. 但恶意节点不能监听两个正常节点间的通信, 也不能获知它没有通信过的正常节点的决策.

恶意节点对应着拜占庭将军的比喻: 拜占庭的许多支军队必须在分开包围的状态下同时攻击敌人, 将军们依靠通信兵互相协商进攻意向和进攻时间, 而叛徒将军可以擅自变更进攻意向或进攻时间. 怎么才能找到一种分布式协议来协商从而让将军一致的行动呢? 拜占庭将军问题的实质, 是指在系统没有中心, 只依靠节点两两通信的情况下, 怎么保证系统能协商一致, 并抵御恶意节点干扰.

恶意节点目标是破坏系统一致性, 想象 `f+1` 个正常节点主张进攻,  `f` 个正常节点主张撤退, `f` 个恶意节点故意选了撤退的场景, 如果经过沟通后, 大家都正确传达了各自的意图, 并且都明白应该选择撤退, 那么我们认为恶意节点并没有达到目的. 只有当恶意节点骗过正常节点, 使主张进攻和主张撤退的节点都以为自己是大多数, 那这是成功的作恶.

能解决拜占庭将军问题的算法, 统称为拜占庭容错算法 (Byzantine Fault Tolerance), 其中的代表有 PBFT 等等.

Practical Byzantine Fault Tolerance 有
无签名和签名适用于同步系统

当节点发现leader作恶时，通过算法选举其他的replica为leader。
2、leader通过pre-prepare 消息把它选择的 value广播给其他replica节点，其他的replica节点如果接受则发送 prepare，如果失败则不发送。
3、一旦2f个节点接受prepare消息，则节点发送commit消息。
4、当2f+1个节点接受commit消息后，代表该value值被确定
如下图表示了4个节点，0为leader，同时节点3为fault节点，该节点不响应和发出任何消息。最终节点状态达到commited时，表示该轮共识成功达成。





**没有搞清楚的问题**

存在 `f` 个恶意节点时, 为什么系统至少要 `3f+1` 个节点才能保证运转?

解释一: 考虑最坏的情况, 系统总共 `N` 个节点, 其中 `f` 个忠诚节点宕机了, 剩下 `N-f` 个存活节点中, `f` 个恶意节点率先返回了假消息, 那么为让系统能正常运行, 我们得至少再等到另外的节点返回了真消息才能胜过 `f` 个假消息, 所以 `N-f-f > f`, 得到 `N > 3f`

解释二: 多数派需要达到 `2f+1`, 任意两个多数派之间至少有 `f+1` 个公共成员，而恶意进程最多 `f` 个










### 比特币共识算法 - 工作量证明

到目前为止, 针对系统中有故障节点的局面, 我们有 Paxos 和 Raft 算法, 对系统中同时有故障节点和恶意节点的局面, 我们有了 BFT 系列算法. 这样可以搭建比特币之类的应用了么? 还是不行. 因为这些算法都太慢了, 它们都是针对小型系统一两百个节点设计的, 没法用在互联网的海量用户中.

直到比特币的出现解决了这个问题, 比特币的共识算法叫做 POW 工作量证明, 核心在于遵守共识的比特币用户是有奖励的, 恶意节点由于只付出代价而收不到奖励, 变相受到了惩罚

之后基于奖励币的思路, 人们又发展出了一堆共识模型, 通称比特币共识

- POW (Proof of Work, 工作量证明) 例如比特币, 下大力气挖矿的人最有可能得到一个满足规则的随机数, 于是有权记账
- POS (Proof of Stake, 股权证明) 例如以太坊, 根据节点所占代币的比例和时间等比例降低挖矿难度, 从而加快找随机数的速度
- DPOS (Delegated Proof of Stake, 委任股权证明) 例如比特股, 类似董事会投票, 持币者投出一定数量的节点代理他们进行验证和记账

上述比特币共识算法, 都脱离不了币的奖励机制, 系统安全是由持币者维护保证的. 但是, 当区块链运用到商业应用时, 其承载的资产价值可能远远超出发行的币的价值, 这时由持币者保证系统安全稳定是不可靠的. POW和POS都是一种随机选择下一个区块上传者的方式

于是区块链的共识算法分成了两大类,

- 公有链: 对应比特币共识, 最多可以抵抗 49% 的恶意节点, 需要依靠币的价值体系, 不能运用在链上承载的价值超过币值的场合
- 私有链, 联盟链: 对应 BFT 共识, 最多可以抵抗 33% 的恶意节点, 不能用在规模巨大的网络


由于私有链是封闭生态的存储系统，因此采用Paxos类系统可以达到最优的性能；联盟链有半公开半开放特性，因此拜占庭容错是适合选择之一，例如IBM超级账本项目；对于公有链来说，这种共识算法的要求已经超出了普通分布式系统构建的范畴，再加上交易的特性，因此需要引入更多的安全考虑。

分布式系统不一定是完全去中心的, 如果它有个中心, 中心很容易成为最脆弱的地方



### 智能合约
